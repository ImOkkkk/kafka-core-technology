## 1.Kafka入门

### 1.1 消息引擎系统ABC

**消息引擎系统**：系统A发送消息给消息引擎系统，系统B从消息引擎系统中读取A发送是消息。

- 传输消息的格式：纯二进制的字节序列，消息还是结构化的，只是在使用之前都要将其转换成二进制的字节序列。
- 传输协议
  - 点对点模型：系统A发送的消息只能被系统B接收，其它任何系统都不能读取A发送的消息。
  - 发布/订阅模型：发送方称为发布者(Publisher)，接收方称为订阅者(Subscriber)，这个模型可能存在多个发布者向相同的主题(Topic)发送消息，而订阅者也可能存在多个，它们都能接收到相同主题的消息。

**填谷削峰**

引入Kafka后，上游订单服务不在直接与服务进行交互。当新订单生成后它仅仅是向Kafka Broker发送一条订单消息即可。下游的各个子服务订阅Kafka中的对应主题，并实时从该主题的各自分区(Partition)中获取到订单消息进行处理，从而实现了上游订单服务与下游订单处理服务的解耦。当出现秒杀业务时，Kafka能够将瞬时增加的订单流量全部以消息形式保存在对应的主题中，既不影响上游服务的TPS，同时也给下游子服务留出了充足的时间去消费它们。

### 1.2 Kafka术语

**生产者(Producer)**和**消费者(Consumer)**统称为**客户端(Clients)**，Kafka的服务器端由被称为**Broker**的服务进程构成，即一个Kafka集群由多个Broker组成，Broker负责接收和处理客户端发送过来的请求。以及对消息进行持久化。(Borker分散运行在不同的机器上)。

相同的数据拷贝到多台机器上，这些相同的数据拷贝在Kafka中称为**副本(Replica)**。**领导者副本(Leader Replica)**：对外提供副本(与客户端程序进行交互)；**追随者副本(Follower Replica)**：被动的追随领导者副本，不能与外界进行交互。**副本的工作机制**：生产者总是向领导者副本写消息，而消费者总是从领导者副本读消息，追随者副本，只做一件事：向领导者副本发送请求，请求领导者把最新生成的消息发给它(保持与领导者同步)。

Kafka中的分区机制指的是将每个主题划分成多个**分区(Partition)**，每个分区是一组有序的消息日志。生产者生产的每条消息**只会被发送到一个分区中**。副本是在分区这个层级定义的，每个分区下可以配置若干个副本，其中只能有1个领导者副本和N-1个追随者副本。生产者向分区写入消息，每条消息在分区中的位置信息由一个叫**位移(Offset)**的数据来表征，分区位移总是从0开始。

**Kafka的三层消息架构**

- 主题层：每个主题可以配置M个分区，而每个分区又可以配置N个副本。
- 分区层：每个分区的N个副本只能有一个充当领导者角色，对外提供服务；其它N-1个副本是追随者副本，只是提供数据冗余之用。
- 消息层：分区中包含若干条消息，每条消息的位移从0开始，依次递增。

客户端程序只能与分区的领导者副本进行交互。

**持久化数据**

Kafka使用消息日志(Log)来保存数据，一个日志就是磁盘上一个只能追加写(Append-only)消息的物理文件(只能追加，避免了缓慢的随机I/O操作，改为性能较好的顺序I/O写操作)。Kafka会定期的删除消息以回收磁盘，**日志段(Log Segment)机制**：一个日志近一步细分成多个日志段，并将老的日志段封存起来，后台定时任务会定期的检查老的日志段是否能够被删除，从而实现回收磁盘空间的目的。

**消费者组(Consumer Group)**，指的是多个消费者实例共同组成一个组来消费一组主题。这组主题中的每个分区都都只会被组内的一个消费者实例消费，其它消费者实例不能消费它。多个消费者实例同时消费，加速整个消费端的吞吐量(TPS)。

**重平衡(Rebalance)**：组内某个实例挂掉了，Kafka能够自动检测到，然后把这个Failed实例之前负责的分区转移给其它活着的消费者。

**消费者位移(Consumer Offser)**：记录了消费者在消费消息过程中消费到了分区的哪个位置上。上面的"位移"表征的是分区内的消息位置，它是不变的，即一旦消息被成功写到到一个分区上，它的位移值就是固定的了。而消费者位移则不同，它可能是随时变化的，是消费者消费进度的指示器，另外每个消费者有着自己的消费者位移。

**总结**

- 消息：Record，Kafka处理的主要对象。
- 主题：Topic，主题是承载消息的逻辑容器，在实际使用中多用来区分具体的业务。
- 分区：Partition，一个有序不变的消息序列，每个主题下可以有多个分区。
- 消息位移：Offset，表示分区中每条消息的位置信息，是一个单调递增且不变的值。
- 副本：Replica，Kafka中同一条消息能够被拷贝多个地方以提供数据冗余，这些地方就是所谓的副本。副本还分为领导者副本和追随者副本。副本是在分区层级下的，即每个分区可配置多个副本实现高可用。
- 生产者：Producer，向主题发布新消息的应用程序。
- 消费者：Consumer，从主题订阅新消息的应用程序。
- 消费者位移：Consumer Offset，表征消费者消费进度，每个消费者都有自己的消费者位移。
- 消费者组：Consumer Group，多个消费者实例共同组成一个组，同时消费多个分区以实现高吞吐。
- 重平衡：Rebalance，消费组内某个消费者实例挂掉后，其它消费者实例自动重新分配订阅主题分区的过程，是Kafka消费者端实现高可用的重要手段。

![](./img/Kafka.png)

### 1.3 Kafka只是消息引擎系统吗？

Kafka是消息引擎系统，也是一个分布式流处理平台。

- 提供一套API实现生产者和消费者；
- 降低网络传输和磁盘存储开销；
- 实现高伸缩性架构。

## 2.Kafka的基本使用

### 2.1 Kafka线上集群部署方案怎么做？

**操作系统**

Linux更加适合Kafka

- I/O模型的使用：阻塞式I/O、非阻塞式I/O、I/O多路复用、信号驱动I/O、异步I/O，Kafka客户端使用了Java的selector，selector在Linux上的实现机制是epoll。
- 数据网络传输效率：零拷贝
- 社区支持度

**磁盘**

Kafka使用方式多是顺序读写，规避了机械硬盘随机读写操作慢的缺点。

磁盘阵列：提供冗余的磁盘存储空间；提供负载均衡。Kafka自己实现了冗余机制提供高可靠性，通过分区实现负载均衡。

**磁盘容量**

每天1亿条1KB大小的消息，保存两份且留存两周：1亿 * 1KB * 2 /1000/1000 = 200GB，其它数据(如索引数据)，预留10%，220GB * 14 = 3TB，假设数据压缩比0.75，0.75 * 3 = 2.25TB

- 新增消息数
- 消息留存时间
- 平均消息大小
- 备份数
- 是否启用压缩

**带宽**

带宽1Gbps(千兆网)，1小时内处理1TB的业务数据(1024 * 1024 / 3600 * 8每秒需要处理2336Mb的数据)，假设每台Kafka机器没有混布其他服务，Kafka用到70%的带宽资源，通常再额外留出2/3的资源，即单台服务器使用带宽1000 * 70% / 3 = 240Mbps。2336/240 = 10，如果消息还需要额外复制两份，那么服务器台数还需要x3，即30台。

![](./img/Kafka部署方案.jfif)